## video1
是时候看看redux拼图的第二块了：reducer
reducer负责创建应用程序的初始状态，之后该状态会保存在store中，但它的原理是什么，类似于redux action只是一个javascript对象。reducer是一个函数，reducer接受两个参数，第一个是当前状态，reducer总是要返回一个状态，

```
function app(state){
return state;
}
```

第二个参数是派发的action，此action
用于决定要对状态作出何种变更,不对，这里你不能说变更，因为你永远不能修改状态，相反 你要复制现有的状态，修改副本 然后返回更新后的副本

```
function app(state,action){
	if(action.type=='ADD_FLAVOR'){
//change app state info
}


return state;

}
```
```
function app(state,action){
	if(action.type=='ADD_FLAVOR'){
		return {
			...state,
			flavors:[...state.flavors,action.flavor]
	};
}


	return state;
}
```
这只是它工作原理的概述，我们来看细节。

action 描述的是应用中发生了某种 action 这一事实，但它们并不关心实际状态应该如何因此而变化。这一点由 reducer 负责。reducer 接收当前状态和被派遣的 action，然后根据所收到的 action 决定如何将当前状态转换为全新的状态。

reducer 如何根据所收到的 action 知道怎样修改应用的状态？我们来看一个示例，了解其中的奥秘。

reducer 就是一个函数，接收当前状态和从 action creator 那返回的具体的 action 为参数：

```
function reducer (state, action) {
   // ...
}
```

reducer 只是一个传入两个参数的函数。接着，在 reducer 中创建一个 switch 语句（或者 if/else 语句），以匹配该 action 的“type”属性，然后根据需要修改状态。

```
function reducer (state, action) {
  switch (action.type) {
    case 'SUBMIT_USER' :
      return Object.assign({}, state, {
        user: action.user
      })
  }
}
```

在上述示例中，每当 submitUser action creator 被调用并传入一个 reducer，我们的 switch 语句就匹配 'SUBMIT_USER' case。然后创建新的状态并向该新状态添加（或进行修改）user 属性，新状态的值是我们一开始传递给 submitUser action creator 的 user。

reducer 的行为存在一些规则。最重要的规则是 reducer 应该为纯函数。


Reducer 的作用只是接受当前状态和一个 action , 并返回新的状态。如果你在 reducer 中执行了其他操作，可能就出错了。reducer 不应该：

* 更改其参数
* 具有副作用（异步请求、更改作用域变量等）
* 使用其他非纯函数

换句话说，reducer 必须是纯函数！

## video2 创建reducer答案
## video3
reducer返回的是应用程序的状态或结构化数据，但是此数据的形状应该是怎样的呢？你是否应该有一个对象数组？还是包含一切数据的单个对象？具体的形状将取决于你的应用的功能，无论你的状态形状最终是什么样的，这事你在开始编写reducer之前就应该决定的事情。你需要花时间思考你的应用如何使用该数据以及那种格式最合适，只有在知道状态形状之后，你才能构建reducer让它以正确的格式返回数据

## Reducer 和状态
Redux 中的 reducer 指定了应用的状态，并根据特定的 action 判断如何更改状态。

使用 ES6 的默认参数特征指定 Reducer 的初始状态。

```
function myReducer (state = initialState, action) {
   // ...
}
```

reducer 所返回的将是应用的新状态，因此你需要确保始终返回新状态或上一个状态。

```
function myReducer (state = initialState, action) {
  if ( /* ... */ ) {
    return {
      ...state,
      name: 'Tyler'
    };
  }

  return state;
}
```

你决定如何更改状态的方式基于派遣的 action 类型。

```
function myReducer (state = initialState, action) {
  if (action.type === CHANGE_NAME) {
    return {
      ...state,
      name: 'Tyler'
    };
  }

  return state;
}
```
为了创建 store，需要将 reducer 函数当做第一个参数传递给 Redux 的 createStore() 方法。createStore() 所返回的就是 store 本身。该 store 具有三个属性：

* getState()
* dispatch()
* subscribe()

### .getState()
store.getState() 不需要任何参数，并且将返回 store 的当前状态。

### .dispatch()
store.dispatch(action) 传入 action 对象，并且将调用 reducer 函数，向其传递当前状态和所派遣的 action。例如：

```
// store.js

import { createStore } from 'redux';
import reducer from '../reducers/reducer';

let store = createStore(reducer);

const receiveComment = comment => ({
  type: 'RECEIVE_COMMENT',
  comment
});

export default store;
```

```
store.getState(); // []
store.dispatch(receiveComment('Redux is great!'));
store.getState(); // ['Redux is great!']
```

### .subscribe()
store.subscribe(cb) 传入监听器回调函数，每当状态改变时，就会调用该函数。

##video2
现在我们有了actions和reducer,接下来我们要创建store了，你可能注意到，到目前为止，我们还未对redux包进行热河具体操作，事实上我们还没有安装他，那么我们先来执行这一步，

##video3
在继续之前我想做的是使redux应用与redux开发工具兼容，这样 我们便能很容易地看到我们向应用程序派发了那些action,我们的状态根据这些action发生了哪些变化等等.
redux插件中的diff会告诉我们之前状态和新状态之间的差别。